Bidsync — System Design & Implementation (Supabase Auth + GraphQL + TanStack Query)

Below is a complete, implementation-ready system document for Bidsync. It targets Supabase as the backend (using supabase.auth for authentication), uses Supabase’s PostgreSQL database (SQL you can run directly in Supabase SQL editor), exposes an autogenerated GraphQL API (pg_graphql), and demonstrates recommended client usage with TanStack Query + graphql-request (following TanStack’s GraphQL guidance). I also include Row Level Security (RLS) policies so the SQL is secure when used with Supabase auth.

Sources & guidance used while preparing this doc: Supabase GraphQL and Auth docs, pg_graphql overview, and TanStack Query GraphQL docs and examples. 
tanstack.com
+3
Supabase
+3
Supabase
+3

1 — High-level architecture

Frontend: Next.js (TypeScript) + React, TanStack Query (v5) + graphql-request, TipTap for rich editing.

Auth: supabase.auth (client SDK) — sign-in, session management, JWTs. 
Supabase

Database: Supabase PostgreSQL (SQL below).

GraphQL API: Supabase’s pg_graphql auto-generated GraphQL endpoint (available at https://<project>.supabase.co/graphql/v1). 
Supabase
+1

Background jobs / AI: QStash / Redis queues or serverless workers (recommended separation).

Storage: Supabase Storage (or S3) for documents & attachments.

Realtime / Notifications: Supabase Realtime (optional) or Webhooks.

2 — SQL schema (run this in Supabase SQL editor)
db/bidsync.sql

3 — GraphQL with Supabase (pg_graphql)

Supabase runs a Postgres extension (pg_graphql) that automatically reflects your SQL schema into GraphQL types and fields. The endpoint is available at:

https://<project-ref>.supabase.co/graphql/v1


You can try queries interactively in Supabase Studio → API Docs → GraphQL (GraphiQL). 
Supabase
+1

Naming & inflection: By default snake_case table/column names are reflected; you can enable inflection in pg_graphql settings if you prefer camelCase GraphQL names. See pg_graphql docs for customization. 
supabase.github.io

4 — Example GraphQL operations

Below are example GraphQL operations that match the schema above. Use these from the client via graphql-request or any GraphQL client.

4.1 Query: list projects for current user (client/team)
query ListProjects {
  projects {
    id
    title
    description
    status
    client_id
    created_at
  }
}

4.2 Query: fetch proposals for a project (with versions & documents)
query ProposalsForProject($project_id: uuid!) {
  proposals(where: { project_id: { _eq: $project_id } }) {
    id
    title
    status
    lead_id
    current_version
    proposal_versions(order_by: { version_number: asc }) {
      version_number
      content
      author_id
      created_at
    }
    documents {
      id
      storage_path
      uploaded_by
      created_at
    }
  }
}

4.3 Mutation: insert a new proposal
mutation InsertProposal($object: proposals_insert_input!) {
  insert_proposals_one(object: $object) {
    id
    title
    lead_id
    project_id
    status
    created_at
  }
}

4.4 Mutation: add a proposal_version
mutation AddProposalVersion($object: proposal_versions_insert_input!) {
  insert_proposal_versions_one(object: $object) {
    id
    version_number
    content
    created_at
  }
}


The exact operation names will reflect how pg_graphql maps your tables—use Supabase GraphiQL to inspect the generated schema. 
supabase.github.io

5 — Client: TanStack Query + graphql-request recommended integration

TanStack Query is framework-agnostic and works well with GraphQL calls using graphql-request. TanStack’s docs show simple, typed usage combined with GraphQL codegen for type safety. 
tanstack.com
+1

5.1 Install (example)
npm install @tanstack/react-query graphql-request
# (optional) install graphql-codegen for better TypeScript types

5.2 Setup GraphQL client + auth header (using supabase auth)
// src/lib/graphqlClient.ts
import { GraphQLClient } from 'graphql-request';
import { createClient } from '@supabase/supabase-js';

export const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export async function getGraphQLClient() {
  // Get current session token
  const {
    data: { session },
  } = await supabase.auth.getSession();

  const headers: Record<string,string> = {};
  if (session?.access_token) {
    headers['Authorization'] = `Bearer ${session.access_token}`;
  }

  return new GraphQLClient(`${process.env.NEXT_PUBLIC_SUPABASE_URL}/graphql/v1`, {
    headers
  });
}

5.3 Example: useQuery with TanStack Query
// src/hooks/useProjects.tsx
import { useQuery } from '@tanstack/react-query';
import { getGraphQLClient } from '../lib/graphqlClient';
import { gql } from 'graphql-request';

const LIST_PROJECTS = gql`
  query ListProjects {
    projects {
      id
      title
      description
      status
      client_id
      created_at
    }
  }
`;

export function useProjects() {
  return useQuery(['projects'], async () => {
    const client = await getGraphQLClient();
    const data = await client.request(LIST_PROJECTS);
    return data.projects;
  }, {
    staleTime: 1000 * 60 * 1, // 1 minute (tune for your product)
  });
}

5.4 Example: mutation (submit proposal) + invalidation
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { gql } from 'graphql-request';
import { getGraphQLClient } from '../lib/graphqlClient';

const SUBMIT_PROPOSAL = gql`
  mutation SubmitProposal($id: uuid!, $status: String!) {
    update_proposals_by_pk(pk_columns: { id: $id }, _set: { status: $status }) {
      id
      status
    }
  }
`;

export function useSubmitProposal() {
  const qc = useQueryClient();
  return useMutation(async ({ id }: { id: string }) => {
    const client = await getGraphQLClient();
    return client.request(SUBMIT_PROPOSAL, { id, status: 'submitted' });
  }, {
    onSuccess: () => {
      // keep UI in sync: invalidate queries that show proposals/projects
      qc.invalidateQueries(['projects']);
      qc.invalidateQueries(['proposals']);
    }
  });
}


Notes & best practices (TanStack):

Keep query keys consistent and granular (e.g., ['proposals', projectId]). 
tanstack.com

Use useMutation for writes and call queryClient.invalidateQueries() on success to refresh relevant queries. 
tanstack.com

Consider optimistic updates for snappy UX for small changes; ensure rollbacks on errors.

6 — Auth & Headers

Use supabase.auth in the frontend to sign-in and manage sessions. The session contains an access_token (JWT) that must be sent in the GraphQL Authorization: Bearer <token> header for row-level policies to evaluate auth.uid() properly. Example sign-in & session management is documented by Supabase. 
Supabase
+1

For server-to-server calls that require admin privileges (e.g., background workers creating entries regardless of user), use the Supabase service_role key on the server only (never expose to clients). Service role bypasses RLS so be careful.

7 — Versioning, diffs & workflow

Store structured content per version in proposal_versions.content (JSONB array with per-section { key, title, body, attachments }).

Diffing strategy: client retrieves two content JSONs and computes section-level diffs (e.g., using diff-match-patch or jsdiff) and highlights changed sections in the UI.

Autosaves: keep ephemeral drafts in Redis (or Supabase storage or ephemeral DB table) and only create a formal proposal_versions record on explicit “Save version” action.

8 — Security & RLS summary

RLS policies above are examples and enforce:

Profiles: users read/update their own profile.

Projects: only client who owns it, its team members, or admins can read/update.

Proposals & versions: only lead, team members, project client, or admin can access.

Always test policies in Supabase Studio (the SQL editor and GraphiQL allow you to emulate requests).

Use service role key only on privileged backend processes.

9 — AI Assistance & background jobs (short plan)

Frontend triggers an AI job (e.g., “generate executive summary”) via a backend endpoint.

Backend enqueues job (Redis / QStash) and worker calls chosen AI (OpenAI or in-house model).

On job completion, worker writes a new proposal_versions entry (or returns a draft to the user for acceptance).

All AI outputs should pass a content moderation filter (toxicity / PII checks) before being stored.

10 — Observability, testing, and dev workflow

Add audit logs (we have activity_log table) for important actions (version created, submit, accept/reject).

Unit & integration tests: test GraphQL operations against a seeded test DB.

Use GraphQL Code Generator and schema introspection to generate TypeScript types and potentially typed hooks (if you want to move beyond manual useQuery wrappers).

Helpful resources: TanStack GraphQL example and GraphQL-Codegen integration are recommended for type-safe operations. 
tanstack.com
+1

11 — Example delivery checklist (MVP)

 Authentication with Supabase (email, magic link, OAuth).

 Database tables & RLS enabled (run SQL above).

 GraphQL endpoint verified in Supabase Studio & GraphiQL.

 Frontend: list/create projects, proposal editor, file upload to Supabase storage.

 Proposal versioning + compare UI.

 Team management & assignments.

 Client review & selection flows.

 Audit logging + basic analytics dashboard.